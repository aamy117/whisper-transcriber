ğŸ“‹ ç¬¬ä¸€éšæ®µå¯¦è¸æ­¥é©Ÿï¼ˆ1é€±ï¼‰
Day 1: å°èˆªç³»çµ±æ•´åˆ + Whisper API é–‹å§‹
ä¸Šåˆï¼šå°èˆªç³»çµ±ï¼ˆ2å°æ™‚ï¼‰
Step 1: å»ºç«‹å…±ç”¨æ¨£å¼æª”æ¡ˆ
bash# å»ºç«‹ shared.css
touch css/shared.css
åœ¨ css/shared.css ä¸­åŠ å…¥ï¼š
css/* å°èˆªåˆ—æ¨£å¼ */
.app-navigation {
  background-color: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 1000;
}

.nav-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--spacing-md);
  display: flex;
  align-items: center;
  height: 56px;
  gap: var(--spacing-lg);
}

.nav-links {
  display: flex;
  gap: var(--spacing-sm);
}

.nav-link {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-sm) var(--spacing-md);
  color: var(--text-secondary);
  text-decoration: none;
  border-radius: var(--radius-md);
  transition: all 0.2s;
}

.nav-link:hover {
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
}

.nav-link.active {
  color: var(--primary-color);
  font-weight: 500;
}
Step 2: ä¿®æ”¹ index.html
åœ¨ <head> ä¸­åŠ å…¥ï¼š
html<link rel="stylesheet" href="css/shared.css">
åœ¨ <body> é–‹é ­ï¼ˆ<div id="app"> ä¹‹å‰ï¼‰åŠ å…¥ï¼š
html<!-- å°èˆªåˆ— -->
<nav class="app-navigation">
    <div class="nav-container">
        <div class="nav-brand">
            <h1 class="nav-title">Whisper å·¥å…·</h1>
        </div>
        <div class="nav-links">
            <a href="index.html" class="nav-link active">
                <span class="nav-icon">ğŸµ</span>
                <span>éŸ³è¨Šå·¥å…·</span>
            </a>
            <a href="video.html" class="nav-link">
                <span class="nav-icon">ğŸ¬</span>
                <span>è¦–è¨Šå·¥å…·</span>
            </a>
        </div>
    </div>
</nav>
Step 3: èª¿æ•´ç¾æœ‰ header æ¨£å¼
ä¿®æ”¹ css/style.cssï¼š
css/* èª¿æ•´ app-headerï¼Œç§»é™¤ sticky */
.app-header {
  position: relative;
  top: auto;
}

/* èª¿æ•´ä¸»å…§å®¹å€å¡Šçš„ä¸Šé‚Šè· */
.app-main {
  padding-top: var(--spacing-md);
}
ä¸‹åˆï¼šWhisper API åŸºç¤æ¶æ§‹ï¼ˆ2å°æ™‚ï¼‰
Step 4: å»ºç«‹ api.js
javascript// js/api.js
class WhisperAPI {
  constructor() {
    this.apiKey = this.getApiKey();
    this.endpoint = Config.api.endpoint;
    this.model = Config.api.model;
  }
  
  getApiKey() {
    return localStorage.getItem(Config.storage.prefix + 'apiKey');
  }
  
  validateApiKey() {
    if (!this.apiKey) {
      throw new Error('API Key æœªè¨­å®š');
    }
    if (!this.apiKey.startsWith('sk-')) {
      throw new Error('API Key æ ¼å¼éŒ¯èª¤');
    }
  }
  
  async transcribe(audioFile, options = {}) {
    try {
      this.validateApiKey();
      
      // æª”æ¡ˆé©—è­‰
      if (audioFile.size > Config.api.maxFileSize) {
        throw new Error(`æª”æ¡ˆå¤§å°è¶…éé™åˆ¶ï¼ˆæœ€å¤§ ${Config.api.maxFileSize / 1024 / 1024}MBï¼‰`);
      }
      
      // å»ºç«‹ FormData
      const formData = new FormData();
      formData.append('file', audioFile);
      formData.append('model', this.model);
      
      // å¯é¸åƒæ•¸
      if (options.language) {
        formData.append('language', options.language);
      }
      if (options.prompt) {
        formData.append('prompt', options.prompt);
      }
      formData.append('response_format', 'verbose_json');
      
      // TODO: å¯¦ä½œ API å‘¼å«
      console.log('æº–å‚™å‘¼å« Whisper API...');
      
    } catch (error) {
      console.error('Transcription error:', error);
      throw error;
    }
  }
}

export { WhisperAPI };
Step 5: åœ¨ main.js ä¸­æ•´åˆ API
javascript// åœ¨ main.js é ‚éƒ¨åŠ å…¥
import { WhisperAPI } from './api.js';

// åœ¨ WhisperApp class ä¸­åŠ å…¥
constructor() {
  // ç¾æœ‰ç¨‹å¼ç¢¼...
  this.whisperAPI = null;
}

// åœ¨ setup() æ–¹æ³•ä¸­
setup() {
  // ç¾æœ‰ç¨‹å¼ç¢¼...
  
  // åˆå§‹åŒ– API
  if (this.apiKey) {
    this.whisperAPI = new WhisperAPI();
  }
}

// ä¿®æ”¹ startTranscription æ–¹æ³•
async startTranscription() {
  if (!this.apiKey) {
    this.showNotification('è«‹å…ˆè¨­å®š API Key', 'error');
    this.showModal(document.getElementById('settingsModal'));
    return;
  }
  
  const file = this.player.getCurrentFile();
  if (!file) {
    this.showNotification('è«‹å…ˆä¸Šå‚³éŸ³è¨Šæª”æ¡ˆ', 'error');
    return;
  }
  
  // åˆå§‹åŒ– APIï¼ˆå¦‚æœé‚„æ²’æœ‰ï¼‰
  if (!this.whisperAPI) {
    this.whisperAPI = new WhisperAPI();
  }
  
  try {
    // é¡¯ç¤ºé€²åº¦
    this.showTranscriptionStatus('æº–å‚™è½‰è­¯...');
    
    // å‘¼å« API
    const result = await this.whisperAPI.transcribe(file, {
      language: 'zh' // é è¨­ä¸­æ–‡
    });
    
    // è™•ç†çµæœ
    this.handleTranscriptionResult(result);
    
  } catch (error) {
    this.showNotification(`è½‰è­¯å¤±æ•—ï¼š${error.message}`, 'error');
    this.hideTranscriptionStatus();
  }
}
Day 2-3: Whisper API å®Œæˆ + Web Audio API æ•´åˆ
Day 2 ä¸Šåˆï¼šå®Œæˆ API å‘¼å«ï¼ˆ2å°æ™‚ï¼‰
Step 6: å¯¦ä½œ API å‘¼å«é‚è¼¯
ä¿®æ”¹ js/api.jsï¼š
javascriptasync transcribe(audioFile, options = {}) {
  try {
    this.validateApiKey();
    
    // æª”æ¡ˆé©—è­‰ï¼ˆå·²æœ‰ï¼‰...
    
    // å»ºç«‹ FormDataï¼ˆå·²æœ‰ï¼‰...
    
    // ç™¼é€è«‹æ±‚
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: formData
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || 'è½‰è­¯å¤±æ•—');
    }
    
    const result = await response.json();
    return this.processResult(result);
    
  } catch (error) {
    console.error('Transcription error:', error);
    throw error;
  }
}

processResult(rawResult) {
  // è™•ç† API å›æ‡‰æ ¼å¼
  return {
    text: rawResult.text,
    segments: rawResult.segments || [],
    language: rawResult.language,
    duration: rawResult.duration
  };
}
Step 7: å»ºç«‹è½‰è­¯ç‹€æ…‹ç®¡ç†
åœ¨ main.js ä¸­åŠ å…¥ï¼š
javascriptshowTranscriptionStatus(message, showProgress = true) {
  const statusSection = document.getElementById('transcriptionStatus');
  const statusMessage = document.getElementById('statusMessage');
  const progressIndicator = document.getElementById('progressIndicator');
  
  statusSection.style.display = 'block';
  statusMessage.textContent = message;
  progressIndicator.style.display = showProgress ? 'block' : 'none';
}

hideTranscriptionStatus() {
  const statusSection = document.getElementById('transcriptionStatus');
  statusSection.style.display = 'none';
}

handleTranscriptionResult(result) {
  // å„²å­˜çµæœ
  this.currentProject = {
    ...this.currentProject,
    transcription: {
      text: result.text,
      segments: result.segments,
      language: result.language,
      createdAt: new Date().toISOString()
    }
  };
  
  // é¡¯ç¤ºçµæœ
  this.displayTranscription();
  
  // éš±è—ç‹€æ…‹
  this.hideTranscriptionStatus();
  
  // å„²å­˜å°ˆæ¡ˆ
  this.saveProject();
}
Day 2 ä¸‹åˆï¼šWeb Audio API åŸºç¤ï¼ˆ2å°æ™‚ï¼‰
Step 8: ä¿®æ”¹ player.js - åŠ å…¥ Web Audio æ”¯æ´
javascript// åœ¨ constructor ä¸­åŠ å…¥
constructor() {
  // ç¾æœ‰å±¬æ€§...
  
  // Web Audio API ç›¸é—œ
  this.webAudioSupported = this.detectWebAudioSupport();
  this.webAudioEnabled = false;
  this.audioContext = null;
  this.sourceNode = null;
  this.filterNode = null;
  this.gainNode = null;
}

// æ–°å¢æ–¹æ³•
detectWebAudioSupport() {
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      const testContext = new AudioContext();
      testContext.close();
      return true;
    }
  } catch (e) {
    console.warn('Web Audio API not supported');
  }
  return false;
}

initWebAudio() {
  if (!this.webAudioSupported || this.audioContext) return;
  
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new AudioContext();
    
    // å»ºç«‹ç¯€é»
    this.sourceNode = this.audioContext.createMediaElementSource(this.audioElement);
    this.filterNode = this.audioContext.createBiquadFilter();
    this.gainNode = this.audioContext.createGain();
    
    // è¨­å®šæ¿¾æ³¢å™¨
    this.filterNode.type = 'lowpass';
    this.filterNode.frequency.value = 3500;
    this.filterNode.Q.value = 0.7;
    
    // é€£æ¥ç¯€é»ï¼ˆå…ˆä¸é€£æ¥æ¿¾æ³¢å™¨ï¼‰
    this.sourceNode.connect(this.gainNode);
    this.gainNode.connect(this.audioContext.destination);
    
    this.webAudioEnabled = true;
    console.log('Web Audio API initialized');
    
  } catch (error) {
    console.error('Web Audio initialization failed:', error);
    this.webAudioSupported = false;
  }
}
Day 3ï¼šWeb Audio é€Ÿåº¦é€£å‹•ï¼ˆ4å°æ™‚ï¼‰
Step 9: å¯¦ä½œé€Ÿåº¦åˆ‡æ›é‚è¼¯
javascript// ä¿®æ”¹ handleSpeedChange æ–¹æ³•
handleSpeedChange(e) {
  const speed = parseFloat(e.target.value);
  this.audioElement.playbackRate = speed;
  
  // Web Audio å„ªåŒ–æ§åˆ¶
  if (this.webAudioSupported && speed >= 1.5) {
    if (!this.webAudioEnabled) {
      this.enableWebAudioOptimization();
    } else {
      this.updateFilterSettings(speed);
    }
  } else if (this.webAudioEnabled && speed < 1.5) {
    this.disableWebAudioOptimization();
  }
}

enableWebAudioOptimization() {
  if (!this.webAudioEnabled) {
    this.initWebAudio();
  }
  
  if (this.webAudioEnabled && this.filterNode) {
    // é‡æ–°é€£æ¥ï¼ŒåŠ å…¥æ¿¾æ³¢å™¨
    this.sourceNode.disconnect();
    this.sourceNode.connect(this.filterNode);
    this.filterNode.connect(this.gainNode);
    
    this.updateFilterSettings(this.audioElement.playbackRate);
    console.log('Web Audio optimization enabled');
  }
}

disableWebAudioOptimization() {
  if (this.webAudioEnabled && this.sourceNode) {
    // ç§»é™¤æ¿¾æ³¢å™¨ï¼Œç›´æ¥é€£æ¥
    this.sourceNode.disconnect();
    this.filterNode.disconnect();
    this.sourceNode.connect(this.gainNode);
    
    console.log('Web Audio optimization disabled');
  }
}

updateFilterSettings(playbackRate) {
  if (!this.filterNode) return;
  
  // æ ¹æ“šé€Ÿåº¦èª¿æ•´æ¿¾æ³¢å™¨é »ç‡
  let frequency = 3500;
  if (playbackRate >= 2.5) {
    frequency = 3000;
  } else if (playbackRate >= 2.0) {
    frequency = 3200;
  }
  
  this.filterNode.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
}
Day 4-5: ç·¨è¼¯å™¨æ ¸å¿ƒåŠŸèƒ½
Day 4ï¼šåŸºç¤ç·¨è¼¯å™¨ï¼ˆ4å°æ™‚ï¼‰
Step 10: å»ºç«‹ editor.js
javascript// js/editor.js
class TranscriptionEditor {
  constructor(containerElement) {
    this.container = containerElement;
    this.segments = [];
    this.currentSegmentIndex = -1;
    this.autoSaveTimer = null;
  }
  
  loadTranscription(transcription) {
    this.segments = transcription.segments.map((seg, index) => ({
      ...seg,
      id: index,
      edited: seg.text,
      isEdited: false
    }));
    
    this.render();
  }
  
  render() {
    this.container.innerHTML = '';
    
    this.segments.forEach(segment => {
      const segmentEl = this.createSegmentElement(segment);
      this.container.appendChild(segmentEl);
    });
  }
  
  createSegmentElement(segment) {
    const div = document.createElement('div');
    div.className = 'segment';
    div.dataset.segmentId = segment.id;
    
    div.innerHTML = `
      <div class="segment-time" data-time="${segment.start}">
        ${this.formatTime(segment.start)}
      </div>
      <div class="segment-text" contenteditable="true">
        ${segment.edited || segment.text}
      </div>
    `;
    
    // ç¶å®šäº‹ä»¶
    const textEl = div.querySelector('.segment-text');
    textEl.addEventListener('input', () => this.handleEdit(segment.id, textEl.textContent));
    textEl.addEventListener('focus', () => this.setCurrentSegment(segment.id));
    
    const timeEl = div.querySelector('.segment-time');
    timeEl.addEventListener('click', () => this.handleTimeClick(segment.start));
    
    return div;
  }
  
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  
  handleEdit(segmentId, newText) {
    const segment = this.segments.find(s => s.id === segmentId);
    if (segment) {
      segment.edited = newText;
      segment.isEdited = segment.edited !== segment.text;
      
      // è§¸ç™¼è‡ªå‹•å„²å­˜
      this.triggerAutoSave();
    }
  }
  
  triggerAutoSave() {
    clearTimeout(this.autoSaveTimer);
    this.autoSaveTimer = setTimeout(() => {
      this.save();
    }, Config.storage.autoSaveInterval);
  }
  
  save() {
    const event = new CustomEvent('editorSave', {
      detail: { segments: this.segments }
    });
    this.container.dispatchEvent(event);
  }
}

export { TranscriptionEditor };
Step 11: æ•´åˆç·¨è¼¯å™¨åˆ° main.js
javascript// åŒ¯å…¥ç·¨è¼¯å™¨
import { TranscriptionEditor } from './editor.js';

// åœ¨ constructor ä¸­
this.editor = null;

// åœ¨ setup ä¸­åˆå§‹åŒ–
const editorContainer = document.getElementById('editorContent');
if (editorContainer) {
  this.editor = new TranscriptionEditor(editorContainer);
  
  // ç›£è½å„²å­˜äº‹ä»¶
  editorContainer.addEventListener('editorSave', (e) => {
    this.handleEditorSave(e.detail);
  });
}

// é¡¯ç¤ºè½‰è­¯çµæœ
displayTranscription() {
  const editorSection = document.getElementById('editorSection');
  editorSection.style.display = 'block';
  
  if (this.editor && this.currentProject.transcription) {
    this.editor.loadTranscription(this.currentProject.transcription);
  }
}
Day 6-7: è³‡æ–™ç®¡ç†èˆ‡åŒ¯å‡º
Day 6ï¼šå°ˆæ¡ˆç®¡ç†ï¼ˆ4å°æ™‚ï¼‰
Step 12: å»ºç«‹ storage.js
javascript// js/storage.js
class ProjectStorage {
  constructor() {
    this.prefix = Config.storage.prefix;
  }
  
  saveProject(project) {
    const key = `${this.prefix}project_${project.id}`;
    localStorage.setItem(key, JSON.stringify(project));
    
    // æ›´æ–°å°ˆæ¡ˆåˆ—è¡¨
    this.updateProjectList(project.id);
  }
  
  loadProject(projectId) {
    const key = `${this.prefix}project_${projectId}`;
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
  }
  
  updateProjectList(projectId) {
    const listKey = `${this.prefix}projectList`;
    let list = this.getProjectList();
    
    if (!list.includes(projectId)) {
      list.push(projectId);
      localStorage.setItem(listKey, JSON.stringify(list));
    }
  }
  
  getProjectList() {
    const listKey = `${this.prefix}projectList`;
    const data = localStorage.getItem(listKey);
    return data ? JSON.parse(data) : [];
  }
  
  deleteProject(projectId) {
    const key = `${this.prefix}project_${projectId}`;
    localStorage.removeItem(key);
    
    // å¾åˆ—è¡¨ä¸­ç§»é™¤
    const list = this.getProjectList().filter(id => id !== projectId);
    localStorage.setItem(`${this.prefix}projectList`, JSON.stringify(list));
  }
}

export { ProjectStorage };
Day 7ï¼šåŒ¯å‡ºåŠŸèƒ½ï¼ˆ4å°æ™‚ï¼‰
Step 13: å»ºç«‹ export.js
javascript// js/shared/export.js
class ExportManager {
  constructor() {
    this.formats = {
      'txt': this.exportToTxt,
      'srt': this.exportToSrt,
      'vtt': this.exportToVtt,
      'txt-timestamps': this.exportToTxtWithTimestamps
    };
  }
  
  export(segments, format, filename) {
    const exportFunc = this.formats[format];
    if (!exportFunc) {
      throw new Error(`ä¸æ”¯æ´çš„æ ¼å¼ï¼š${format}`);
    }
    
    const content = exportFunc.call(this, segments);
    this.download(content, filename, format);
  }
  
  exportToTxt(segments) {
    return segments
      .map(seg => seg.edited || seg.text)
      .join('\n\n');
  }
  
  exportToSrt(segments) {
    return segments
      .map((seg, index) => {
        const start = this.formatSrtTime(seg.start);
        const end = this.formatSrtTime(seg.end);
        return `${index + 1}\n${start} --> ${end}\n${seg.edited || seg.text}\n`;
      })
      .join('\n');
  }
  
  exportToVtt(segments) {
    let vtt = 'WEBVTT\n\n';
    return vtt + segments
      .map(seg => {
        const start = this.formatVttTime(seg.start);
        const end = this.formatVttTime(seg.end);
        return `${start} --> ${end}\n${seg.edited || seg.text}\n`;
      })
      .join('\n');
  }
  
  exportToTxtWithTimestamps(segments) {
    return segments
      .map(seg => {
        const time = this.formatTime(seg.start);
        return `[${time}] ${seg.edited || seg.text}`;
      })
      .join('\n\n');
  }
  
  download(content, filename, format) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.${format === 'txt-timestamps' ? 'txt' : format}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  formatSrtTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
  }
  
  formatVttTime(seconds) {
    // VTT ä½¿ç”¨é»è€Œéé€—è™Ÿ
    return this.formatSrtTime(seconds).replace(',', '.');
  }
  
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
}

export { ExportManager };
ğŸ“ æ¸¬è©¦æª¢æŸ¥æ¸…å–®
æ¯æ—¥å®Œæˆæª¢æŸ¥

 ç¨‹å¼ç¢¼å¯æ­£å¸¸åŸ·è¡Œ
 ç„¡ console éŒ¯èª¤
 åŠŸèƒ½ç¬¦åˆé æœŸ
 Git commit å®Œæˆ

ç¬¬ä¸€éšæ®µå®Œæˆæ¨™æº–

 å°èˆªåˆ—æ­£å¸¸é¡¯ç¤º
 API Key è¨­å®šåŠŸèƒ½å®Œæ•´
 å¯æˆåŠŸå‘¼å« Whisper API
 Web Audio åœ¨ 1.5x è‡ªå‹•å•Ÿç”¨
 ç·¨è¼¯å™¨å¯ç·¨è¼¯å’Œå„²å­˜
 åŒ¯å‡ºåŠŸèƒ½æ­£å¸¸é‹ä½œ

ğŸš€ ç«‹å³å¯åŸ·è¡Œçš„ç¬¬ä¸€æ­¥

å»ºç«‹ css/shared.css ä¸¦åŠ å…¥å°èˆªåˆ—æ¨£å¼
ä¿®æ”¹ index.html åŠ å…¥å°èˆªåˆ—å’Œå…±ç”¨æ¨£å¼é€£çµ
å»ºç«‹ js/api.js ä¸¦é–‹å§‹å¯¦ä½œ WhisperAPI é¡åˆ¥
åœ¨ main.js ä¸­æ•´åˆ API å‘¼å«é‚è¼¯