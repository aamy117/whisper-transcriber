<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>修復驗證測試</title>
  <link rel="stylesheet" href="../css/style.css">
  <style>
    .test-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .test-section {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .test-result.success {
      background: #d4edda;
      color: #155724;
    }
    .test-result.error {
      background: #f8d7da;
      color: #721c24;
    }
    .test-result.warning {
      background: #fff3cd;
      color: #856404;
    }
    .memory-info {
      font-family: monospace;
      background: #e9ecef;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .test-controls {
      margin: 20px 0;
    }
    .test-controls button {
      margin-right: 10px;
    }
    #memoryChart {
      width: 100%;
      height: 200px;
      border: 1px solid #ddd;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>修復驗證測試套件</h1>
    
    <div class="test-controls">
      <button onclick="runAllTests()">執行所有測試</button>
      <button onclick="clearResults()">清除結果</button>
      <button onclick="startMemoryMonitor()">開始記憶體監控</button>
      <button onclick="stopMemoryMonitor()">停止記憶體監控</button>
    </div>

    <div id="memoryInfo" class="memory-info">
      記憶體使用情況將顯示在這裡...
    </div>
    
    <canvas id="memoryChart"></canvas>

    <!-- 測試 1: 記憶體洩漏修復 -->
    <div class="test-section">
      <h2>測試 1: AudioPlayer 記憶體洩漏修復</h2>
      <p>測試 Blob URL 是否正確釋放</p>
      <button onclick="testMemoryLeak()">執行測試</button>
      <div id="test1Results"></div>
    </div>

    <!-- 測試 2: 音訊分割記憶體效率 -->
    <div class="test-section">
      <h2>測試 2: 音訊分割記憶體效率</h2>
      <p>測試 ArrayBuffer 是否避免不必要的複製</p>
      <button onclick="testAudioSplitterMemory()">執行測試</button>
      <div id="test2Results"></div>
    </div>

    <!-- 測試 3: WASM 降級功能 -->
    <div class="test-section">
      <h2>測試 3: WASM 降級功能</h2>
      <p>測試 WASM 載入失敗時的降級處理</p>
      <button onclick="testWASMFallback()">執行測試</button>
      <div id="test3Results"></div>
    </div>

    <!-- 測試 4: 虛擬滾動效能 -->
    <div class="test-section">
      <h2>測試 4: 虛擬滾動效能</h2>
      <p>測試二分搜尋優化的效能提升</p>
      <button onclick="testVirtualScrollPerformance()">執行測試</button>
      <div id="test4Results"></div>
    </div>

    <!-- 測試 5: 整合測試 -->
    <div class="test-section">
      <h2>測試 5: 整合測試</h2>
      <p>測試完整的檔案載入和處理流程</p>
      <input type="file" id="testFile" accept="audio/*">
      <button onclick="testIntegration()">執行整合測試</button>
      <div id="test5Results"></div>
    </div>
  </div>

  <script type="module">
    import { AudioPlayer } from '../js/player.js';
    import { AudioSplitter } from '../js/audio-splitter.js';
    import { WhisperWASMManager } from '../js/wasm/whisper-wasm-manager.js';
    import { VirtualScrollManager } from '../js/virtual-scroll-manager.js';
    
    // 記憶體監控
    let memoryMonitorInterval = null;
    const memoryHistory = [];
    const maxHistoryPoints = 50;
    
    window.startMemoryMonitor = function() {
      if (!performance.memory) {
        addResult('memoryInfo', '您的瀏覽器不支援記憶體監控', 'warning');
        return;
      }
      
      stopMemoryMonitor();
      memoryHistory.length = 0;
      
      memoryMonitorInterval = setInterval(() => {
        const memInfo = performance.memory;
        const used = memInfo.usedJSHeapSize / 1024 / 1024;
        const total = memInfo.totalJSHeapSize / 1024 / 1024;
        const limit = memInfo.jsHeapSizeLimit / 1024 / 1024;
        
        memoryHistory.push({
          time: Date.now(),
          used: used,
          total: total
        });
        
        if (memoryHistory.length > maxHistoryPoints) {
          memoryHistory.shift();
        }
        
        document.getElementById('memoryInfo').innerHTML = `
          <strong>記憶體使用情況：</strong><br>
          已使用: ${used.toFixed(2)} MB<br>
          總分配: ${total.toFixed(2)} MB<br>
          限制: ${limit.toFixed(2)} MB<br>
          使用率: ${((used / limit) * 100).toFixed(2)}%
        `;
        
        drawMemoryChart();
      }, 1000);
    };
    
    window.stopMemoryMonitor = function() {
      if (memoryMonitorInterval) {
        clearInterval(memoryMonitorInterval);
        memoryMonitorInterval = null;
      }
    };
    
    function drawMemoryChart() {
      const canvas = document.getElementById('memoryChart');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.offsetWidth;
      const height = canvas.height = 200;
      
      ctx.clearRect(0, 0, width, height);
      
      if (memoryHistory.length < 2) return;
      
      // 找出最大值
      const maxMemory = Math.max(...memoryHistory.map(h => h.used));
      const scale = height / (maxMemory * 1.2);
      
      // 繪製網格
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = (height / 5) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // 繪製記憶體使用曲線
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      memoryHistory.forEach((point, index) => {
        const x = (index / (memoryHistory.length - 1)) * width;
        const y = height - (point.used * scale);
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
    }
    
    // 測試結果顯示
    function addResult(containerId, message, type = 'success') {
      const container = document.getElementById(containerId);
      const result = document.createElement('div');
      result.className = `test-result ${type}`;
      result.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      container.appendChild(result);
    }
    
    // 測試 1: 記憶體洩漏修復
    window.testMemoryLeak = async function() {
      const results = document.getElementById('test1Results');
      results.innerHTML = '';
      
      try {
        addResult('test1Results', '開始測試 AudioPlayer 記憶體洩漏修復...');
        
        const player = new AudioPlayer();
        
        // 檢查是否有 cleanup 方法
        if (typeof player.cleanup !== 'function') {
          addResult('test1Results', '❌ AudioPlayer 缺少 cleanup 方法', 'error');
          return;
        }
        
        // 創建測試檔案
        const audioData = new Float32Array(44100); // 1秒的靜音
        const blob = new Blob([audioData], { type: 'audio/wav' });
        const file = new File([blob], 'test.wav', { type: 'audio/wav' });
        
        // 記錄初始 Blob URL 數量
        const initialUrls = performance.memory ? performance.memory.usedJSHeapSize : 0;
        
        // 多次載入和清理
        for (let i = 0; i < 10; i++) {
          player.loadAudioFile(file);
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // 檢查 currentBlobUrl 是否存在
          if (!player.currentBlobUrl) {
            addResult('test1Results', `❌ 第 ${i + 1} 次載入後 currentBlobUrl 未設置`, 'error');
            return;
          }
        }
        
        // 執行清理
        player.cleanup();
        
        // 檢查清理後的狀態
        if (player.currentBlobUrl !== null) {
          addResult('test1Results', '❌ cleanup 後 currentBlobUrl 未清空', 'error');
          return;
        }
        
        addResult('test1Results', '✅ AudioPlayer 記憶體洩漏修復測試通過');
        
        // 強制垃圾回收（如果可用）
        if (window.gc) {
          window.gc();
          addResult('test1Results', '已觸發垃圾回收');
        }
        
      } catch (error) {
        addResult('test1Results', `❌ 測試失敗: ${error.message}`, 'error');
        console.error(error);
      }
    };
    
    // 測試 2: 音訊分割記憶體效率
    window.testAudioSplitterMemory = async function() {
      const results = document.getElementById('test2Results');
      results.innerHTML = '';
      
      try {
        addResult('test2Results', '開始測試音訊分割記憶體效率...');
        
        const splitter = new AudioSplitter();
        
        // 創建測試資料
        const testSize = 10 * 1024 * 1024; // 10MB
        const arrayBuffer = new ArrayBuffer(testSize);
        const view = new Uint8Array(arrayBuffer);
        
        // 填充一些資料
        for (let i = 0; i < view.length; i += 1000) {
          view[i] = Math.random() * 255;
        }
        
        // 記錄初始記憶體
        const memBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
        
        // 檢查程式碼是否包含 slice(0)
        const splitMethod = splitter.split.toString();
        if (splitMethod.includes('arrayBuffer.slice(0)')) {
          addResult('test2Results', '❌ 程式碼仍包含 arrayBuffer.slice(0)', 'error');
          return;
        }
        
        addResult('test2Results', '✅ 程式碼已移除不必要的 arrayBuffer.slice(0)');
        addResult('test2Results', '✅ 音訊分割記憶體效率測試通過');
        
        // 記錄記憶體差異
        const memAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
        const memDiff = (memAfter - memBefore) / 1024 / 1024;
        addResult('test2Results', `記憶體使用差異: ${memDiff.toFixed(2)} MB`);
        
      } catch (error) {
        addResult('test2Results', `❌ 測試失敗: ${error.message}`, 'error');
        console.error(error);
      }
    };
    
    // 測試 3: WASM 降級功能
    window.testWASMFallback = async function() {
      const results = document.getElementById('test3Results');
      results.innerHTML = '';
      
      try {
        addResult('test3Results', '開始測試 WASM 降級功能...');
        
        const wasmManager = new WhisperWASMManager();
        
        // 檢查 loadWASMModule 方法
        const loadMethod = wasmManager.loadWASMModule.toString();
        if (loadMethod.includes('throw new Error')) {
          addResult('test3Results', '❌ loadWASMModule 仍在拋出錯誤', 'error');
          return;
        }
        
        // 嘗試載入 WASM
        let error = null;
        try {
          await wasmManager.loadWASMModule();
        } catch (e) {
          error = e;
        }
        
        if (error) {
          addResult('test3Results', `❌ WASM 載入失敗: ${error.message}`, 'error');
          return;
        }
        
        // 檢查是否降級成功
        if (wasmManager.ENABLE_REAL_WASM === false) {
          addResult('test3Results', '✅ 成功降級到 Transformers.js');
        } else {
          addResult('test3Results', '⚠️ WASM 載入成功但未降級', 'warning');
        }
        
        addResult('test3Results', '✅ WASM 降級功能測試通過');
        
      } catch (error) {
        addResult('test3Results', `❌ 測試失敗: ${error.message}`, 'error');
        console.error(error);
      }
    };
    
    // 測試 4: 虛擬滾動效能
    window.testVirtualScrollPerformance = async function() {
      const results = document.getElementById('test4Results');
      results.innerHTML = '';
      
      try {
        addResult('test4Results', '開始測試虛擬滾動效能...');
        
        const vsManager = new VirtualScrollManager({
          itemHeight: 50,
          bufferSize: 5
        });
        
        // 創建測試資料
        const testItems = Array.from({ length: 10000 }, (_, i) => ({
          id: i,
          text: `Item ${i}`
        }));
        
        vsManager.setItems(testItems);
        
        // 測試 findIndexAtOffset 效能
        const testOffsets = [0, 2500, 5000, 7500, 10000, 250000, 500000];
        const iterations = 1000;
        
        // 測試原始線性搜尋（模擬）
        const linearStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          for (const offset of testOffsets) {
            // 模擬線性搜尋
            let accHeight = 0;
            for (let j = 0; j < testItems.length; j++) {
              accHeight += 50;
              if (accHeight > offset) break;
            }
          }
        }
        const linearTime = performance.now() - linearStart;
        
        // 測試優化後的二分搜尋
        const binaryStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          for (const offset of testOffsets) {
            vsManager.findIndexAtOffset(offset);
          }
        }
        const binaryTime = performance.now() - binaryStart;
        
        const improvement = ((linearTime - binaryTime) / linearTime) * 100;
        
        addResult('test4Results', `線性搜尋時間: ${linearTime.toFixed(2)}ms`);
        addResult('test4Results', `二分搜尋時間: ${binaryTime.toFixed(2)}ms`);
        addResult('test4Results', `效能提升: ${improvement.toFixed(2)}%`);
        
        if (binaryTime < linearTime) {
          addResult('test4Results', '✅ 虛擬滾動效能優化測試通過');
        } else {
          addResult('test4Results', '❌ 效能未提升', 'error');
        }
        
      } catch (error) {
        addResult('test4Results', `❌ 測試失敗: ${error.message}`, 'error');
        console.error(error);
      }
    };
    
    // 測試 5: 整合測試
    window.testIntegration = async function() {
      const results = document.getElementById('test5Results');
      results.innerHTML = '';
      
      const fileInput = document.getElementById('testFile');
      const file = fileInput.files[0];
      
      if (!file) {
        addResult('test5Results', '請選擇一個音訊檔案', 'warning');
        return;
      }
      
      try {
        addResult('test5Results', '開始整合測試...');
        
        // 測試 AudioPlayer
        const player = new AudioPlayer();
        const loadSuccess = player.loadAudioFile(file);
        
        if (loadSuccess !== false) {
          addResult('test5Results', '✅ AudioPlayer 載入成功');
        } else {
          addResult('test5Results', '❌ AudioPlayer 載入失敗', 'error');
        }
        
        // 測試記憶體狀態
        if (player.currentBlobUrl) {
          addResult('test5Results', '✅ Blob URL 已創建');
        }
        
        // 清理
        player.cleanup();
        
        if (!player.currentBlobUrl) {
          addResult('test5Results', '✅ 清理後 Blob URL 已釋放');
        }
        
        // 測試 WASM Manager
        const wasmManager = new WhisperWASMManager();
        await wasmManager.initialize('tiny');
        
        addResult('test5Results', '✅ WASM Manager 初始化成功');
        
        addResult('test5Results', '✅ 整合測試完成');
        
      } catch (error) {
        addResult('test5Results', `❌ 測試失敗: ${error.message}`, 'error');
        console.error(error);
      }
    };
    
    // 執行所有測試
    window.runAllTests = async function() {
      await testMemoryLeak();
      await testAudioSplitterMemory();
      await testWASMFallback();
      await testVirtualScrollPerformance();
    };
    
    // 清除結果
    window.clearResults = function() {
      ['test1Results', 'test2Results', 'test3Results', 'test4Results', 'test5Results'].forEach(id => {
        document.getElementById(id).innerHTML = '';
      });
    };
    
    // 自動開始記憶體監控
    startMemoryMonitor();
  </script>
</body>
</html>